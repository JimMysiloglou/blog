[
  {
    "objectID": "blog/metronomes/Synchronising_metronomes.html",
    "href": "blog/metronomes/Synchronising_metronomes.html",
    "title": "Synchronization of Metronomes",
    "section": "",
    "text": "The idea is that every number of oscillators (like the metronomes) will come into synchronization when coupled together. While each metronome has a different natural frequency, the interaction between them due to the board underneath(which moves freely) makes them synchronized with each other (phase lock). You can find the video here.\nThe first person that noticed this phenomenon was a Dutch scientist and engineer called Christiaan Huygens in 1665. He invented the pendulum clock which was a breakthrough in timekeeping and the most accurate timekeeper for the next 300 years. Huygens noticed that when two pendulum clocks hung from the same wood beam, each pendula always moved opposite of one another so that when one was on the furthest left, the other would be on the furthest right and vice versa (anti-phase). No matter how he disturbed their rhythm, the clocks would always come back to the same relative orientation, what he later called “the sympathy of two clocks”. After some experiments, he decided that each pendulum caused an imperceptible motion in the beam which they were hanging, and that motion tended to force the other pendulum toward moving in the same phase. Once the pendula were synchronized, their opposite forces would cancel and the beam would stay still.\nWhile Huygens noticed the phenomenon of spontaneous synchronization in the 17th century, there is still ongoing research about it because it can be found in many different natural systems. It can be observed in circadian rhythms, heart & intestinal muscles, insulin-secreting cells in the pancreas, and fireflies’ light turning on and off at the same time, among others. There is a nice video about the phenomenon on the youtube channel “Veritasium” which you can find here.\nThe mathematical model that Matt Parker uses in his video was created by Yoshiki Kuramoto in 1975. The governing equation of the model is: \\[\\dot{θ} = ω_{i} + \\frac{K}{N}\\sum_{j=1}^{N}sin(θ_{j}-θ_{i}), \\;\\;  i=1,...,N\\]\nwhere \\(ω_{i}\\) is the oscillators’ natural frequencies, K is the coupling constant and N is the total number of oscillators. Next, I will try to model synchronization in Python language. I created a class called Metronome that initializes metronome instances, each with an initial offset. The calculate_synchronization method applies the Kuramoto model on all instances created and calculates the new offset. The calculate_phase method calculates each metronome instance’s phase given the offset, before and after the synchronization. Finally, to create new instances I clear the metronomes list with the method clear_metronomes.\nBelow are examples of 3, 4, and 6 metronomes with an equal distance from each other. Finally an example with 5 metronomes at a random distance. Note that I changed the coupling distance, depending on the number of metronomes and the phase distance between them to synchronize within the same time limit.\n\n\nImporting numpy and matplotlib\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\nsns.set_theme(context='talk', style='ticks', palette='colorblind', font_scale=1.2)\n\n\n\nclass Metronome:\n    \"\"\"\n    The class creates metronome instances\n    \n    Attributes:\n        X (numpy.ndarray): time\n        k (float): coupling constant\n        metronomes_list (list): a list containing all created instances\n    \"\"\"\n\n    X = np.linspace(0, 100, 1000)\n    k = 0.005\n    metronomes_list = []\n\n\n    def __init__(self, initial_offset):\n        \"\"\"Creates a metronome instance with an initial phase\n        that is not sychronized with the other instances.\n        \"\"\"\n\n        self.offset = np.array([initial_offset])\n        self.y = self.calculate_phase(initial_offset)\n        self.metronomes_list.append(self)\n\n    def calculate_phase(self, offset):\n        \"\"\"Calculates phase based on instanse's offset\"\"\"\n        return np.sin(self.X + offset)\n\n    @classmethod\n    def calculate_synchronization(cls):\n        \"\"\"Calculates synchronization for all instances created.\"\"\"\n\n        for i in range(1, len(cls.X)):\n            for metronome in cls.metronomes_list:\n                new_offset = metronome.offset[i-1] +\\\n                             ((cls.k/len(cls.metronomes_list)) * \n                               np.sum([np.sin(metronome_other.offset[i-1] - metronome.offset[i-1])\n                                       for metronome_other in cls.metronomes_list\n                                       if metronome != metronome_other]))\n                metronome.offset = np.append(metronome.offset, new_offset)\n        \n        for metronome in cls.metronomes_list:\n            metronome.y = metronome.calculate_phase(metronome.offset)\n\n    @classmethod\n    def clear_metronomes(cls):\n        \"\"\"Reinitialize the list of instances.\"\"\"\n        \n        cls.metronomes_list = []\n\n\n\nA plotting function\ndef plot_metronomes(title):\n    \"\"\"Creates a lineplot for each metronome instance saved in Metronome list.\"\"\"\n\n    plt.figure(figsize=(22, 6))\n    plt.axhline(0, color='grey', linestyle='--', alpha=0.5)\n\n    for metronome in Metronome.metronomes_list:\n        plt.plot(metronome.X, metronome.y)\n        \n    plt.title(title)\n    plt.xlabel('Time')\n    plt.show()\n\n\n\n\n3 metronomes in equal distance\nm1 = Metronome(0)\nm2 = Metronome(np.pi/2)\nm3 = Metronome(np.pi)\n\nplot_metronomes('3 metronomes without sychronization')\n\nMetronome.calculate_synchronization()\n\nplot_metronomes('3 metronomes with sychronization')\n\n\n\n\n\n\n\n\n\n\n4 metronomes in equal distance\nMetronome.clear_metronomes()\n\nm1 = Metronome(0)\nm2 = Metronome(np.pi/2)\nm3 = Metronome(np.pi)\nm4 = Metronome(3*np.pi/4)\n\nplot_metronomes('4 metronomes without sychronization')\n\nMetronome.calculate_synchronization()\n\nplot_metronomes('4 metronomes with synchronization')\n\n\n\n\n\n\n\n\n\n\n6 metronomes in equal distance\nMetronome.clear_metronomes()\nMetronome.k = 0.11\n\nm1 = Metronome(0)\nm2 = Metronome(np.pi/3)\nm3 = Metronome(2*np.pi/3)\nm4 = Metronome(np.pi)\nm5 = Metronome(4*np.pi/3)\nm6 = Metronome(5*np.pi/3)\n\nplot_metronomes('6 metronomes without synchronization')\n\nMetronome.calculate_synchronization()\n\nplot_metronomes('6 metronomes with synchronization')\n\n\n\n\n\n\n\n\n\n\n5 metronomes with random phase\nMetronome.clear_metronomes()\nMetronome.k = 0.008\n\nm1 = Metronome(np.random.uniform(0, 2*np.pi))\nm2 = Metronome(np.random.uniform(0, 2*np.pi))\nm3 = Metronome(np.random.uniform(0, 2*np.pi))\nm4 = Metronome(np.random.uniform(0, 2*np.pi))\nm5 = Metronome(np.random.uniform(0, 2*np.pi))\n\nplot_metronomes('5 metronomes without synchronization')\n\nMetronome.calculate_synchronization()\n\nplot_metronomes('5 metronomes with synchronization')\n\n\n\n\n\n\n\n\nΠηγές:\n\nBryan Daniels, Synchronization of Globally Coupled Nonlinear Oscillators, Ohio Wesleyan University, http://go.owu.edu/~physics/StudentResearch/2005/BryanDaniels/index.html\nHarvard Natural Sciences Lecture Demonstrations, Synchronization of Metronomes, Harvard University, https://sciencedemonstrations.fas.harvard.edu/presentations/synchronization-metronomes\nJonatan Pena Ramirez, Henk Nijmeijer, The secret of the synchronized pendulums, physicsworld, https://physicsworld.com/a/the-secret-of-the-synchronized-pendulums/"
  },
  {
    "objectID": "blog.html",
    "href": "blog.html",
    "title": "My Articles",
    "section": "",
    "text": "Order By\n       Default\n         \n          Title\n        \n         \n          Date - Oldest\n        \n         \n          Date - Newest\n        \n     \n  \n\n\n\n\n  \n\n\n\n\n\n\n\n\n\n\nnumpy\n\n\nmatplotlib\n\n\n\n\nA simple python class to model the sychronization of coupled metronomes.\n\n\n\n\n\n\n2022-10-10\n\n\n2 min\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "portfolio.html",
    "href": "portfolio.html",
    "title": "My Portfolio",
    "section": "",
    "text": "A personal website to host my articles and projects regarding Data Science.\n\n\n\n2022-09-20\n\n\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "portfolio/my_website.html",
    "href": "portfolio/my_website.html",
    "title": "My personal website",
    "section": "",
    "text": "I was fortunate to take a series of online classes about Web Development using HTML, CSS, and JavaScript and the python framework Flask on a Greek MOOC platform called Mathesis. Flask is a microweb framework designed to help you create the backend of a website with as few computing resources as possible. It supports extensions that can add new features according to your needs. Well-known applications like Pinterest and LinkedIn are using Flask. For those speaking English, I recommend Miguel Grinberg’s book Flask Web Development: Developing Web Applications with Python and his blog https://blog.miguelgrinberg.com, both excellent sources of reference for anything relating to the Flask framework. A second book that will help you master the framework is Mastering Flask Web Development by Daniel Gaspar and Jack Stouffer on Packt.\nWith the extension Flask-Babel, the site can support multiple languages. On my first website iteration, I also used Flask-CKEditor. CKEditor is a rich text editor which enables writing content directly inside of web pages or online applications used by many blogs and note-taking apps. Though CKEditor is a powerful editor, I quickly understand that I needed something oriented specifically to data science. When you start learning about Data Science you usually also learn to use Jupyter Notebooks. Notebooks are a great tool to quickly try new ideas, reiterate and present code along with charts and your conclusions. However, Notebook’s format is not well suited for a published article or a report. That’s what Quarto is coming to solve.\nQuarto is an open-source scientific and technical publishing system built on Pandoc. It can be used with R, Python, Julia, and Observable JS and integrated with VS Code, Jupyter, R Studio, or even a simple text editor. You can publish high-quality articles, reports, presentations, and books by transforming markdown files or Jupyter Notebooks to HTML, pdf, Word Documents, epub books, etc. With Quarto, you can also create a static website or blog and publish it on GitHub Pages, Netlify, RStudio Connect, or any other static-hosting service. You don’t even need to learn Flask, maybe a little HTML and CSS, just enough to change the default bootstrap templates to your liking. In addition to the documentation there are two great articles about blogging with Quarto, the first one is taking about setting up your blog and the second one about dual language support.\nSo I decided to combine my original Flask website with a static one on Github. The first one is hosted on pythonanywhere, presenting the blog index and portfolio index, a contact, and an about page. The second one is responsible for the article and project pages. I create them with either markdown or Jupyter, upload them on Github, and list them on my original site with a title, a description, a photo, and a link."
  }
]